// === package.json ===
{
  "name": "whisper",
  "version": "1.0.0",
  "description": "Privacy-first authentication storing only usernames and password hashes",
  "main": "src/index.js",
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "start": "node example/server.js",
    "dev": "nodemon example/server.js"
  },
  "keywords": ["auth", "authentication", "privacy", "minimal", "anonymous"],
  "author": "Your Name",
  "license": "MIT",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "sqlite3": "^5.1.6"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.0.2",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5"
  }
}

// === src/index.js ===
const bcrypt = require('bcrypt');
const sqlite3 = require('sqlite3').verbose();
const crypto = require('crypto');

class Whisper {
  constructor(options = {}) {
    this.dbPath = options.dbPath || ':memory:';
    this.saltRounds = options.saltRounds || 10;
    this.guestTokenExpiry = options.guestTokenExpiry || 30 * 24 * 60 * 60 * 1000; // 30 days
    
    this.db = new sqlite3.Database(this.dbPath);
    this.setupDatabase();
  }

  setupDatabase() {
    const queries = [
      `CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username VARCHAR(50) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`,
      
      `CREATE TABLE IF NOT EXISTS sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        token VARCHAR(255) UNIQUE NOT NULL,
        expires_at TIMESTAMP NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
      )`,
      
      `CREATE TABLE IF NOT EXISTS purchases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        guest_token VARCHAR(100),
        transaction_id VARCHAR(100) UNIQUE NOT NULL,
        amount DECIMAL(10, 2) NOT NULL,
        currency VARCHAR(3) DEFAULT 'USD',
        status VARCHAR(20) DEFAULT 'completed',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
      )`,
      
      `CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token)`,
      `CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)`,
      `CREATE INDEX IF NOT EXISTS idx_purchases_user ON purchases(user_id)`,
      `CREATE INDEX IF NOT EXISTS idx_purchases_guest ON purchases(guest_token)`
    ];

    queries.forEach(query => {
      this.db.run(query, (err) => {
        if (err) console.error('Database setup error:', err);
      });
    });
  }

  // === USER MANAGEMENT ===
  
  async createUser(username, password) {
    // Validate inputs
    if (!username || !password) {
      throw new Error('Username and password are required');
    }
    
    if (username.length < 3 || username.length > 50) {
      throw new Error('Username must be between 3 and 50 characters');
    }
    
    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
      throw new Error('Username can only contain letters, numbers, underscores, and hyphens');
    }
    
    if (password.length < 8) {
      throw new Error('Password must be at least 8 characters long');
    }

    const hashedPassword = await bcrypt.hash(password, this.saltRounds);
    
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO users (username, password_hash) VALUES (?, ?)',
        [username.toLowerCase(), hashedPassword],
        function(err) {
          if (err) {
            if (err.message.includes('UNIQUE constraint failed')) {
              reject(new Error('Username already exists'));
            } else {
              reject(err);
            }
          } else {
            resolve({ id: this.lastID, username: username.toLowerCase() });
          }
        }
      );
    });
  }

  async verifyUser(username, password) {
    if (!username || !password) {
      return null;
    }

    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT id, username, password_hash FROM users WHERE username = ?',
        [username.toLowerCase()],
        async (err, user) => {
          if (err) {
            reject(err);
          } else if (!user) {
            resolve(null);
          } else {
            const match = await bcrypt.compare(password, user.password_hash);
            if (match) {
              resolve({ id: user.id, username: user.username });
            } else {
              resolve(null);
            }
          }
        }
      );
    });
  }

  async changePassword(userId, oldPassword, newPassword) {
    if (newPassword.length < 8) {
      throw new Error('New password must be at least 8 characters long');
    }

    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT password_hash FROM users WHERE id = ?',
        [userId],
        async (err, user) => {
          if (err) {
            reject(err);
          } else if (!user) {
            reject(new Error('User not found'));
          } else {
            const match = await bcrypt.compare(oldPassword, user.password_hash);
            if (!match) {
              reject(new Error('Current password is incorrect'));
            } else {
              const hashedPassword = await bcrypt.hash(newPassword, this.saltRounds);
              this.db.run(
                'UPDATE users SET password_hash = ? WHERE id = ?',
                [hashedPassword, userId],
                (err) => {
                  if (err) reject(err);
                  else resolve(true);
                }
              );
            }
          }
        }
      );
    });
  }

  async deleteUser(userId) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM users WHERE id = ?',
        [userId],
        function(err) {
          if (err) reject(err);
          else resolve(this.changes > 0);
        }
      );
    });
  }

  // === SESSION MANAGEMENT ===
  
  generateToken() {
    return crypto.randomBytes(32).toString('hex');
  }

  async createSession(userId, expiresIn = 7 * 24 * 60 * 60 * 1000) { // 7 days default
    const token = this.generateToken();
    const expiresAt = new Date(Date.now() + expiresIn);
    
    return new Promise((resolve, reject) => {
      this.db.run(
        'INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)',
        [userId, token, expiresAt.toISOString()],
        function(err) {
          if (err) reject(err);
          else resolve({ token, expiresAt });
        }
      );
    });
  }

  async verifySession(token) {
    if (!token) return null;
    
    return new Promise((resolve, reject) => {
      this.db.get(
        `SELECT s.*, u.username 
         FROM sessions s 
         JOIN users u ON s.user_id = u.id 
         WHERE s.token = ? AND s.expires_at > datetime('now')`,
        [token],
        (err, session) => {
          if (err) reject(err);
          else resolve(session ? { userId: session.user_id, username: session.username } : null);
        }
      );
    });
  }

  async revokeSession(token) {
    return new Promise((resolve, reject) => {
      this.db.run(
        'DELETE FROM sessions WHERE token = ?',
        [token],
        function(err) {
          if (err) reject(err);
          else resolve(this.changes > 0);
        }
      );
    });
  }

  async cleanupExpiredSessions() {
    return new Promise((resolve, reject) => {
      this.db.run(
        "DELETE FROM sessions WHERE expires_at < datetime('now')",
        function(err) {
          if (err) reject(err);
          else resolve(this.changes);
        }
      );
    });
  }

  // === PURCHASE MANAGEMENT ===
  
  async recordPurchase(transactionId, amount, currency = 'USD', userId = null, guestToken = null) {
    if (!transactionId || !amount) {
      throw new Error('Transaction ID and amount are required');
    }
    
    if (!userId && !guestToken) {
      guestToken = this.generateGuestToken();
    }
    
    return new Promise((resolve, reject) => {
      this.db.run(
        `INSERT INTO purchases (user_id, guest_token, transaction_id, amount, currency) 
         VALUES (?, ?, ?, ?, ?)`,
        [userId, guestToken, transactionId, amount, currency],
        function(err) {
          if (err) {
            if (err.message.includes('UNIQUE constraint failed')) {
              reject(new Error('Transaction already recorded'));
            } else {
              reject(err);
            }
          } else {
            resolve({ 
              id: this.lastID, 
              transactionId, 
              guestToken,
              amount,
              currency
            });
          }
        }
      );
    });
  }

  generateGuestToken() {
    return 'guest_' + crypto.randomBytes(16).toString('hex');
  }

  async getUserPurchases(userId) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM purchases WHERE user_id = ? ORDER BY created_at DESC',
        [userId],
        (err, purchases) => {
          if (err) reject(err);
          else resolve(purchases);
        }
      );
    });
  }

  async getGuestPurchases(guestToken) {
    return new Promise((resolve, reject) => {
      this.db.all(
        'SELECT * FROM purchases WHERE guest_token = ? ORDER BY created_at DESC',
        [guestToken],
        (err, purchases) => {
          if (err) reject(err);
          else resolve(purchases);
        }
      );
    });
  }

  // === UTILITY METHODS ===
  
  async getUserCount() {
    return new Promise((resolve, reject) => {
      this.db.get(
        'SELECT COUNT(*) as count FROM users',
        (err, result) => {
          if (err) reject(err);
          else resolve(result.count);
        }
      );
    });
  }

  async close() {
    return new Promise((resolve, reject) => {
      this.db.close((err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }
}

module.exports = Whisper;
