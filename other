# === examples/python/whisper.py ===
import bcrypt
import sqlite3
import secrets
import re
from datetime import datetime, timedelta
from typing import Optional, Dict, List, Tuple

class Whisper:
    def __init__(self, db_path: str = ':memory:', salt_rounds: int = 10):
        self.db_path = db_path
        self.salt_rounds = salt_rounds
        self.conn = sqlite3.connect(db_path)
        self.conn.row_factory = sqlite3.Row
        self.setup_database()
    
    def setup_database(self):
        """Initialize database tables"""
        queries = [
            """CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )""",
            
            """CREATE TABLE IF NOT EXISTS sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER NOT NULL,
                token TEXT UNIQUE NOT NULL,
                expires_at TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
            )""",
            
            """CREATE TABLE IF NOT EXISTS purchases (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                guest_token TEXT,
                transaction_id TEXT UNIQUE NOT NULL,
                amount REAL NOT NULL,
                currency TEXT DEFAULT 'USD',
                status TEXT DEFAULT 'completed',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
            )""",
            
            "CREATE INDEX IF NOT EXISTS idx_sessions_token ON sessions(token)",
            "CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at)",
            "CREATE INDEX IF NOT EXISTS idx_purchases_user ON purchases(user_id)",
            "CREATE INDEX IF NOT EXISTS idx_purchases_guest ON purchases(guest_token)"
        ]
        
        cursor = self.conn.cursor()
        for query in queries:
            cursor.execute(query)
        self.conn.commit()
    
    # === USER MANAGEMENT ===
    
    def create_user(self, username: str, password: str) -> Dict[str, any]:
        """Create a new user with username and password"""
        # Validate inputs
        if not username or not password:
            raise ValueError("Username and password are required")
        
        if len(username) < 3 or len(username) > 50:
            raise ValueError("Username must be between 3 and 50 characters")
        
        if not re.match(r'^[a-zA-Z0-9_-]+$', username):
            raise ValueError("Username can only contain letters, numbers, underscores, and hyphens")
        
        if len(password) < 8:
            raise ValueError("Password must be at least 8 characters long")
        
        # Hash password
        password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(self.salt_rounds))
        
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                "INSERT INTO users (username, password_hash) VALUES (?, ?)",
                (username.lower(), password_hash)
            )
            self.conn.commit()
            
            return {
                'id': cursor.lastrowid,
                'username': username.lower()
            }
        except sqlite3.IntegrityError:
            raise ValueError("Username already exists")
    
    def verify_user(self, username: str, password: str) -> Optional[Dict[str, any]]:
        """Verify user credentials"""
        if not username or not password:
            return None
        
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT id, username, password_hash FROM users WHERE username = ?",
            (username.lower(),)
        )
        user = cursor.fetchone()
        
        if user and bcrypt.checkpw(password.encode('utf-8'), user['password_hash']):
            return {
                'id': user['id'],
                'username': user['username']
            }
        
        return None
    
    def change_password(self, user_id: int, old_password: str, new_password: str) -> bool:
        """Change user password"""
        if len(new_password) < 8:
            raise ValueError("New password must be at least 8 characters long")
        
        cursor = self.conn.cursor()
        cursor.execute("SELECT password_hash FROM users WHERE id = ?", (user_id,))
        user = cursor.fetchone()
        
        if not user:
            raise ValueError("User not found")
        
        if not bcrypt.checkpw(old_password.encode('utf-8'), user['password_hash']):
            raise ValueError("Current password is incorrect")
        
        new_hash = bcrypt.hashpw(new_password.encode('utf-8'), bcrypt.gensalt(self.salt_rounds))
        cursor.execute("UPDATE users SET password_hash = ? WHERE id = ?", (new_hash, user_id))
        self.conn.commit()
        
        return True
    
    def delete_user(self, user_id: int) -> bool:
        """Delete a user account"""
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM users WHERE id = ?", (user_id,))
        self.conn.commit()
        return cursor.rowcount > 0
    
    # === SESSION MANAGEMENT ===
    
    def generate_token(self) -> str:
        """Generate a secure random token"""
        return secrets.token_urlsafe(32)
    
    def create_session(self, user_id: int, expires_in_hours: int = 168) -> Dict[str, any]:
        """Create a new session for a user (default 7 days)"""
        token = self.generate_token()
        expires_at = datetime.now() + timedelta(hours=expires_in_hours)
        
        cursor = self.conn.cursor()
        cursor.execute(
            "INSERT INTO sessions (user_id, token, expires_at) VALUES (?, ?, ?)",
            (user_id, token, expires_at)
        )
        self.conn.commit()
        
        return {
            'token': token,
            'expires_at': expires_at
        }
    
    def verify_session(self, token: str) -> Optional[Dict[str, any]]:
        """Verify a session token"""
        if not token:
            return None
        
        cursor = self.conn.cursor()
        cursor.execute(
            """SELECT s.*, u.username 
               FROM sessions s 
               JOIN users u ON s.user_id = u.id 
               WHERE s.token = ? AND s.expires_at > datetime('now')""",
            (token,)
        )
        session = cursor.fetchone()
        
        if session:
            return {
                'user_id': session['user_id'],
                'username': session['username']
            }
        
        return None
    
    def revoke_session(self, token: str) -> bool:
        """Revoke a session"""
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM sessions WHERE token = ?", (token,))
        self.conn.commit()
        return cursor.rowcount > 0
    
    def cleanup_expired_sessions(self) -> int:
        """Remove expired sessions"""
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM sessions WHERE expires_at < datetime('now')")
        self.conn.commit()
        return cursor.rowcount
    
    # === PURCHASE MANAGEMENT ===
    
    def generate_guest_token(self) -> str:
        """Generate a guest token"""
        return f"guest_{secrets.token_urlsafe(16)}"
    
    def record_purchase(self, transaction_id: str, amount: float, 
                       currency: str = 'USD', user_id: Optional[int] = None, 
                       guest_token: Optional[str] = None) -> Dict[str, any]:
        """Record a purchase"""
        if not transaction_id or amount is None:
            raise ValueError("Transaction ID and amount are required")
        
        if not user_id and not guest_token:
            guest_token = self.generate_guest_token()
        
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                """INSERT INTO purchases (user_id, guest_token, transaction_id, amount, currency) 
                   VALUES (?, ?, ?, ?, ?)""",
                (user_id, guest_token, transaction_id, amount, currency)
            )
            self.conn.commit()
            
            return {
                'id': cursor.lastrowid,
                'transaction_id': transaction_id,
                'guest_token': guest_token,
                'amount': amount,
                'currency': currency
            }
        except sqlite3.IntegrityError:
            raise ValueError("Transaction already recorded")
    
    def get_user_purchases(self, user_id: int) -> List[Dict]:
        """Get all purchases for a user"""
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT * FROM purchases WHERE user_id = ? ORDER BY created_at DESC",
            (user_id,)
        )
        return [dict(row) for row in cursor.fetchall()]
    
    def get_guest_purchases(self, guest_token: str) -> List[Dict]:
        """Get all purchases for a guest"""
        cursor = self.conn.cursor()
        cursor.execute(
            "SELECT * FROM purchases WHERE guest_token = ? ORDER BY created_at DESC",
            (guest_token,)
        )
        return [dict(row) for row in cursor.fetchall()]
    
    # === UTILITY METHODS ===
    
    def get_user_count(self) -> int:
        """Get total number of users"""
        cursor = self.conn.cursor()
        cursor.execute("SELECT COUNT(*) as count FROM users")
        return cursor.fetchone()['count']
    
    def close(self):
        """Close database connection"""
        self.conn.close()


# === examples/python/example_usage.py ===
from whisper import Whisper

def main():
    # Initialize Whisper
    auth = Whisper(db_path='whisper.db')
    
    try:
        # Create a user
        print("Creating user...")
        user = auth.create_user('demo_user', 'secure_password123')
        print(f"User created: {user}")
        
        # Verify credentials
        print("\nVerifying credentials...")
        verified = auth.verify_user('demo_user', 'secure_password123')
        print(f"Login successful: {verified}")
        
        # Create session
        print("\nCreating session...")
        session = auth.create_session(user['id'])
        print(f"Session created: {session['token']}")
        
        # Verify session
        print("\nVerifying session...")
        session_data = auth.verify_session(session['token'])
        print(f"Session valid for user: {session_data}")
        
        # Record a purchase
        print("\nRecording purchase...")
        purchase = auth.record_purchase('tx_12345', 99.99, 'USD', user['id'])
        print(f"Purchase recorded: {purchase}")
        
        # Get user purchases
        print("\nGetting user purchases...")
        purchases = auth.get_user_purchases(user['id'])
        print(f"User has {len(purchases)} purchase(s)")
        
        # Guest purchase
        print("\nRecording guest purchase...")
        guest_purchase = auth.record_purchase('tx_67890', 49.99)
        print(f"Guest purchase recorded with token: {guest_purchase['guest_token']}")
        
        # Stats
        print(f"\nTotal users: {auth.get_user_count()}")
        
    except Exception as e:
        print(f"Error: {e}")
    finally:
        auth.close()

if __name__ == "__main__":
    main()


# === examples/python/requirements.txt ===
bcrypt==4.1.2
flask==3.0.0
flask-limiter==3.5.0


# === docs/API.md ===
# Whisper API Documentation

## Core Methods

### User Management

#### `createUser(username, password)`
Creates a new user account.

**Parameters:**
- `username` (string): 3-50 characters, alphanumeric with underscores/hyphens
- `password` (string): Minimum 8 characters

**Returns:** User object with `id` and `username`

**Throws:** Error if username exists or validation fails

---

#### `verifyUser(username, password)`
Verifies user credentials.

**Parameters:**
- `username` (string): The username to verify
- `password` (string): The password to verify

**Returns:** User object if valid, `null` otherwise

---

#### `changePassword(userId, oldPassword, newPassword)`
Changes a user's password.

**Parameters:**
- `userId` (number): The user's ID
- `oldPassword` (string): Current password
- `newPassword` (string): New password (min 8 chars)

**Returns:** `true` on success

**Throws:** Error if old password is incorrect

---

### Session Management

#### `createSession(userId, expiresIn)`
Creates a new session token.

**Parameters:**
- `userId` (number): The user's ID
- `expiresIn` (number): Optional, milliseconds until expiry (default 7 days)

**Returns:** Object with `token` and `expiresAt`

---

#### `verifySession(token)`
Verifies a session token.

**Parameters:**
- `token` (string): The session token

**Returns:** Object with `userId` and `username` if valid, `null` otherwise

---

### Purchase Management

#### `recordPurchase(transactionId, amount, currency, userId, guestToken)`
Records a purchase transaction.

**Parameters:**
- `transactionId` (string): Unique transaction ID from payment processor
- `amount` (number): Purchase amount
- `currency` (string): Currency code (default 'USD')
- `userId` (number): Optional, for authenticated users
- `guestToken` (string): Optional, for guest purchases

**Returns:** Purchase object

**Note:** If neither userId nor guestToken provided, generates a guest token

---

## REST API Endpoints

### Authentication

#### `POST /api/register`
Create a new user account.

**Body:**
```json
{
  "username": "string",
  "password": "string"
}
```

**Response:**
```json
{
  "success": true,
  "token": "string",
  "expiresAt": "datetime"
}
```

---

#### `POST /api/login`
Login with credentials.

**Body:**
```json
{
  "username": "string",
  "password": "string"
}
```

**Response:**
```json
{
  "success": true,
  "token": "string",
  "expiresAt": "datetime"
}
```

---

### Purchases

#### `POST /api/purchase`
Record authenticated purchase.

**Headers:**
- `Authorization: Bearer <token>`

**Body:**
```json
{
  "transactionId": "string",
  "amount": "number",
  "currency": "string"
}
```

---

#### `POST /api/guest-purchase`
Record guest purchase.

**Body:**
```json
{
  "transactionId": "string",
  "amount": "number",
  "currency": "string"
}
```

**Response includes `guestToken` for tracking**
